#!/usr/bin/env python
"""
author: J Cook, Feb 2020

Driver script for Python wrapper to the DISORT library that allows SNICAR style input parameter
definitions, calculation of optical thicknesses for mixed ice/impurity layers and operation
over a wavelength range rather than monochrome calculations.

SNICAR inputs re used to define an optical thickness, ssa and gg for each vertical layer - these
are then fed into DISORT.

Module '_disort' is auto-generated with f2py (version:2).

RUN THIS SCRIPT FROM THE TERMINAL!

i.e
cd /home/joe/Code/pyDISORT/test/
python DISORT_driver.py


"""

import disort
import numpy as np
import matplotlib.pyplot as plt
import setup_SNICAR

save_path = '/home/joe/Code/pyDISORT/' # path to save figures to

DIRECT = 1        # 1= Direct-beam incident flux, 0= Diffuse incident flux
DELTA = 1        # 1= Apply Delta approximation, 0= No delta
MIE = True          # use single scattering optical properties generating using Mie scattering
GO = False          # use single scattering optical properties generating using geometric optics

#############################################
## 3. SET PHYSICAL PROPERTIES OF THE ICE/SNOW

dz = [0.001, 0.01, 0.01, 0.1, 0.1] # thickness of each vertical layer (unit = m)
nbr_lyr = len(dz)  # number of snow layers
R_sfc = 0.15 # reflectance of undrlying surface - set across all wavelengths
rho_snw = [600, 600, 600, 600, 600] # density of each layer (unit = kg m-3)

# SET ICE GRAIN DIMENSIONS
# if using Mie optical properties, set rds_snw
rds_snw = [1500,1500,1500,1500,1500]

# if using GeometricOptics, set side_length and depth
side_length = [3000,4000,5000,5000,5000]
depth = [3000,4000,5000,5000,5000]

# SET IMPURITY MASS CONCENTRATIONS IN EACH LAYER
# units are ppb or ng/g i.e. 1e3 = 1 ppm or 1 ug/g, 1e6 = 1 ppt or 1 mg/g

mss_cnc_soot1 = [0,0,0,0,0]    # uncoated black carbon
mss_cnc_soot2 = [0,0,0,0,0]    # coated black carbon
mss_cnc_dust1 = [0,0,0,0,0]    # global average dust 1
mss_cnc_dust2 = [0,0,0,0,0]    # global average dust 2
mss_cnc_dust3 = [0,0,0,0,0]    # global average dust 3
mss_cnc_dust4 = [0,0,0,0,0]    # global average dust 4
mss_cnc_ash1 = [0,0,0,0,0]    # volcanic ash species 1
mss_cnc_GRISdust1 = [0,0,0,0,0]    # GRIS dust 1 (Cook et al. 2019 "mean")
mss_cnc_GRISdust2 = [0,0,0,0,0]    # GRIS dust 2 (Cook et al. 2019 HIGH)
mss_cnc_GRISdust3 = [0,0,0,0,1]    # GRIS dust 3 (Cook et al. 2019 LOW)
mss_cnc_GRISdustP1 = [0,0,0,0,0]  # GRIS dust 1 (Polashenki2015: low hematite)
mss_cnc_GRISdustP2 = [0,0,0,0,0]  # GRIS dust 1 (Polashenki2015: median hematite)
mss_cnc_GRISdustP3 = [0,0,0,0,0]  # GRIS dust 1 (Polashenki2015: median hematite)
mss_cnc_snw_alg = [0,0,0,0,0]    # Snow Algae (spherical, C nivalis)
mss_cnc_glacier_algae1 = [80000,0,0,0,0]    # glacier algae type1
mss_cnc_glacier_algae2 = [0,0,0,0,0]    # glacier algae type2

# DISORT CONFIG
prnt = np.array([False, False, False, False, False]) # determines what info to print to console
umu = 1.  # cosine of viewing zenith angle
coszen = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9] # cosine of solar zenith angle
phi0 = [0.]  # solar azimuth angle
phi = 0. # viewing azimuth angle
albedo = 0.2  # albedo of underlying surface
uTau = 0.  # optical thickness where fluxes are calculated
Nstr = 32 # number of streams to include in model

# RETRIEVE OPTICAL THICKNESS, SSA, ASYMMETRY PARAMETER FROM SNICAR
[flx_slr, g_star, SSA_star, tau_star, wvl] = setup_SNICAR.setup_SNICAR(
    MIE, GO, DIRECT, DELTA, R_sfc, dz, rho_snw, rds_snw, side_length, depth, nbr_lyr,
    mss_cnc_soot1, mss_cnc_soot2, mss_cnc_dust1, mss_cnc_dust2,
    mss_cnc_dust3, mss_cnc_dust4, mss_cnc_ash1, mss_cnc_GRISdust1,
    mss_cnc_GRISdust2, mss_cnc_GRISdust3, mss_cnc_GRISdustP1,
    mss_cnc_GRISdustP2, mss_cnc_GRISdustP3, mss_cnc_snw_alg, mss_cnc_glacier_algae1,
    mss_cnc_glacier_algae2)

fbeam = flx_slr # incoming irradiance (output by SNICAR)

# G_STAR, SSA_STAR, G_STAR, fbeam are all arrays generated by the snicar function
# containing values at each wavelength. Each call to DISORT takes
# a single value representing one wavelength. The monochrome versions
# of each variable are aliased gg, w0 and dTau for feeding into disort.

def run_disort(gg, w0, dTau, umu0, umu, phi0, phi, albedo, uTau, fbeam, prnt):

    [rfldir, rfldn, flup, dfdt, uavg, uu, albmed, trnmed] =\
                                    disort.run(dTau = dTau, w0=w0, iphas=iphas, gg=gg,
                                            umu0=umu0, phi0=phi0, albedo=albedo, fbeam=fbeam,
                                                utau=uTau, umu=umu, phi=phi, prnt=prnt, UsrAng=True,
                                                    onlyFl=False, Nstr=Nstr)
    alb = flup/(rfldir+rfldn) # calculate albedo from upwards and downards fluxes

    return alb

### SET UP OUTPUT ARRAYS
alb_out = np.zeros(shape=(len(coszen),len(wvl)))
BBA_out = np.zeros(shape=(len(coszen),1))
counter = 0

#################################
# CALL DISORT
#################################
for i in range(10):
for ang in coszen:   # iterate over cosine of solar zenith angle
    for i in range(len(wvl)): # iterate over wavelength

        dTau = tau_star[:,i]
        w0 = SSA_star[:,i]
        iphas = np.ones(len(dz),dtype='int')*2
        iphas[:] = 3
        gg = g_star[:,i]
        umu0 = ang
        alb = run_disort(gg, w0, dTau, umu0, umu, phi0, phi, albedo, uTau, fbeam, prnt)

        alb_out[counter,i] = alb

    # calculcate broadband albedo
    BBA_out[counter,:] = np.sum(alb_out[counter,:]*flx_slr)/np.sum(flx_slr)

    counter+=1

################################
# PLOT FIGURES
################################

# plot albedo at each solar zenith
plt.figure()
alb_mean = np.mean(alb_out,axis=0)
for i in range(len(coszen)):
    plt.plot(wvl[0:250],alb_out[i,0:250],label='coszen: {}'.format(str(coszen[i])))
plt.plot(wvl[0:250],alb_mean[0:250],linestyle='dashed',color='k',label='zenMean')
plt.ylabel('Albedo')
plt.xlabel('Wavelength')
plt.xlim(0.35,2.5)
plt.legend()
plt.savefig(str(save_path+'albedo_DISORT.png'))

plt.figure()
plt.plot(coszen,BBA_out)
plt.xlabel('Cosine of solar zenith')
plt.ylabel('BBA')
plt.ylim(0,1)
plt.savefig(str(save_path+'BBA_DISORT.png'))

print(BBA_out)
